# Abort中断机制

Abort中断机制是combi默认推荐的一种错误处理方式，特征如下：

*   基于php违例机制设计，通过设置```全局捕获```与```try..catch```语法处理抛出的中断消息
*   推荐通过错误号来识别异常，这样可以更少地定义Exception类，或直接使用SPL提供的几个违例
*   中断的相关信息和建议处理方式等均可以在中断发生的地方给出，更自然更通用

## 使用abort语句

推荐在combi项目的文件开头加上以下use语句以便于简单地使用中断，脚手架创建的文件会自带该声明。

```php
use Combi\Core\Abort as abort;
```

当错误发生时，抛出中断：

```php
use Combi\Core\Abort as abort;

if (!$user) {
    throw abort::unexpectedValue('User is not found', 21001);
}
```

如上所示，当用户对象为null时，抛出错误号为21001的中断，其包含的违例对象为```\UnexpectedValueException```。这种通过重载创建Abort中断对象的方式，会默认创建根空间下末尾为Exception的违例对象。这主要是针对SPL提供的几个默认违例。

顶部的use语句同样为框架推荐，脚手架会自动生成。

如果需要使用其他违例类作为违例实体，可以使用下面的语句。

```php
if (!$user) {
    throw abort::with(new MyException('User is not found', 21001));
}
```

## 原生违例

违例对象本身主要包括了文字消息与错误号，外加上一个违例及类名等信息。Abort对象本身也是一个违例，在调用abort语句时，会创建一个Abort对象，并将违例实体作为previous参数传给Abort。

当需要获取原生违例时，可以调用getPrevious()方法获取：

```php
$raw = $abort->getPrevious();
```

需要判断原生违例类时，abort对象提供了一个简单一点的方法：

```php
if ($abort->class() == UnexpectedValueException::class) {
    // do something..
}
```

## 设置中断属性

abort机制的目的之一，就是使得不需要通过定义很多的违例类，即可在错误发生的地点把相关的信息传递出来。因此abort对象包含了一个collection对象，假设要违例发生点需要传递用户id，那么可以这么用：

```php
$user = User::find($user_id);
if (!$user) {
    throw abort::unexpectedValue('User is not found', 21001)
        ->set('user_id', $user_id);
}
```

这样在捕获点，则可以根据传出来的user_id进行处理：

```php
try {
    //...
} catch (abort $abort) {
    if ($abort->getCode() == 21001) {
        // 忽略用户id=100的错误
        if ($abort->get('user_id') != 100) {
            throw $abort;
        }
    }
}
```

中断属性除了提供错误发生时必要的信息，也可以提供其他指导参数，假设我们在业务接口中约定了一个参数show，来控制是否显示此错误。这样在错误发生点，我们可以提供一个推荐的处理方式，比如这里打算隐藏该错误。

```php
$user = User::find($user_id);
if (!$user) {
    throw abort::unexpectedValue('User is not found', 21001)
        ->set('user_id', $user_id)
        ->set('show', 0);
}
```

像这样，你可以通过多次调用set方法来给中断设置多个要传递的参数。

### 中断消息模版与转换输出

中断消息支持combi框架内建的一个简单模版规则。你可以这样描述错误：

```php
$abort = abort::unexpectedValue('User {user_id} is not found', 21001)
    ->set('user_id', 100)
    ->set('show', 0);
throw $abort;
```

这时直接输出```$abort```你会看到：

```php
echo $abort;
// print like this: {"message":"User 100 is not found","code":21001,"file":"/src/classes/Core/Abort.php","line":32,"extra":{"user_id":100,"show":0}}
```

abort支持几种转换输出的方式：

```php
var_dump($abort->toArray());    // 转换为数组
var_dump($abort);               // 调试输出，结果与上面一致
echo json_encode($abort);       // 转换为json格式
echo $abort;                    // 转换为字串输出，结果与上面一致
```

当使用这几种转换方式输出，或是使用combi内建的日志和调试模块的话，message中的```{user_id}```会被中断消息中的同名键值替换。

>   模版规则也支持``` :user_id ```这种形式，前后有空格要求。

>   注意，Exception中的getMessage()被标记为final，所以调用```$abort->getMessage()```不会触发模版机制。

# Tris调试模块

combi内置的简单调试模块叫tris，其包括了调试输出、全局异常捕获及日志相关功能。

框架推荐在文件开头使用use语句引用tris的门面类，以简化调用方式。使用脚手架创建文件会自动生成该声明。

```php
use Combi\Facades\Tris as tris;
```

tris有独立的配置文件```tris.neon```，用于分别管理dumper、catcher及日志等模块。如果需要修改tris的配置，可以在主包中创建配置```src/config/core/tris.neon```，以覆盖core包中的默认配置。

## 调试输出

使用```du()```方法对要检查的变量调试输出。

```php
tris::du($user);
```

如果变量是一个对象，du()方法会检查是否包括```toArray()```或是```__toString()```方法，有的话会调用。对于不同的输出环境，如页面或是命令行，du()指令也会尽量适配。

如果要打印的条目较多，希望加以区分，可以在输出时给定一个标题：

```php
tris::du($user, 'user');
```

### 调试并中止程序

类似laravel，tris也提供了dd()方法：

```php
tris::dd($user);
```

### 测试中输出

提供了dt()方法，供单元测试中使用。

```php
tris::debugTurnOn();

tris::dt($user);

tris::debugTurnOff();
```

dt()方法会把变量打印到debug级别的日志中，而不是输出到页面或命令行。关于日志，见下文说明。

和du()/dd()不同，dt()方法只在```debugTurnOn()/debugTurnOff()```之间工作。

### 获取代码段执行时间

debugTurnOff()会返回一组数组，其中包括了代码段的执行时间（单位毫秒），你可以这样获取：

```php
tris::debugTurnOn();

// your code..

// 获取代码段耗时到$timecost变量
['timecost' => $timecost] = tris::debugTurnOff();
```

### 修改dumper配置

tris的dumper配置在tris.neon中如下所示：

```neon
dumper:
    provider:   Combi\Tris\Dumper
```

可以修改dumper类为自定义类。例如创建dumper对象：

```php
namespace MyZone;

use Combi\Tris\Interfaces;
use Combi\Common\Traits;

class MyDumper implements Interfaces\Dumper
{
    use Traits\Singleton;

    public function dump($var, $title = null): self {
        if ($title) echo "\n# $title\n";
        var_export($var);
        return $this;
    }
}
```

在```src\config\core\tris.neon```中修改相关配置：

```neon
dumper:
    provider:   MyZone\MyDumper
```

## 异常捕获

combi框架默认的Catcher配置提供了以下全局处理机制：

*   全局错误捕获，并将错误转换为ErrorException抛出
*   全局违例捕获，对未捕获的违例进行默认处理

### 错误转违例

对于大多数的php错误，Catcher会将其转换为ErrorException对象抛出，并将错误发生所在作用域的环境变量带入context中。

### 违例捕获

对于未被try..catch语法捕获的错误，会记录日志。如果是非生产环境，会根据catcher配置，决定是否打印输出违例信息。

### Catcher的配置

可以在```src\config\core\tris.neon```中修改相关配置：


```neon
catcher:
    provider:   Combi\Tris\Catcher
    print_exc:      true
```

设置print_exc为false，则在全局捕获违例时不会输出违例信息。

# 日志系统

tris内置了一个结构简单的可扩展日志系统。在框架中简单记录一条日志方式如下：

```php
tris::log('has error');
```

如果需要额外记录一些信息，可以通过扩展参数传递：

```php
tris::log('has error', [
    'user_id'   => $user_id,
]);
```

该方法的完整定义为：

```php
public static function log($message,
        array $context = [],
        string $level = 'debug',
        string $channel = 'default'): void
```

## 日志路径

日志文件的路径由以下组成：

```<logroot>/<channel>/<slice><suffix>```

*   logroot 指在基础配置文件中logs项所标注的目录，默认在主包的```logs```目录下
*   channel 日志所使用的频道，默认为default
*   slice   基于日期的文件分片名，由tris日志配置控制
*   suffix  日志名后缀，由tris日志配置控制

### 日志文件分片

日志文件分片的配置在tris.neon中可进行配置：

```neon
logger:
    default:
        slice_format:       Y.W
```

默认是以```年.周```格式进行分片。

### 日志后缀名

日志后缀配置在tris.neon中进行配置：


```neon
logger:
    default:
        file_suffix:        ".{level}.log"
```

在分片模版中支持变量```{level}```，当模版中包含此变量时，则不同级别的日志会记录到不同的文件中。

这样，在默认配置下，2017年第40周的info级别日志会写入```logs/default/2017.40.info.log```文件中。

## 日志文件格式

日志文件为json格式，以行划分，每个json结构中包括以下字段：

*   datetime    日期
*   channel     频道
*   message     消息体
*   context     扩展参数
*   primary     关联id
*   debugvars   上下文变量，仅ErrorException违例才有
*   level       日志级别

### 日期格式

每条日志的日期格式在tris.neon中配置：

```neon
logger:
    default:
        datetime_format:    c
```

### 对违例等对象的支持

message消息体允许传对象/违例等变量，日志系统会根据对象类型进行处理：

*   为违例/错误对象时： 获取违例中的message，将违例放入context扩展参数的```exception```字段
*   拥有```toArray()```方法： 调用```toArray()```方法转为数组替换到message
*   拥有```__toString()```方法： 调用```__toString()```转为字串替换到message
*   剩下的： 将对象转为数组替换到message

原传入的message对象均会存在context扩展参数的raw字段中。

## 日志对象

除了直接记录数据，tris还提供了```ml()```方法以返回一个Log对象，这样可以更方便地设置日志数据。

```php
$log = tris::ml($exception);
```

如果要把日志以error级别写入，就调用error()方法，类似的方法以重载实现：

```php
$log->error();
```

如果message是违例对象，也可以使用其他未在Psr中定义的错误级别，这时会有一套规则来选择用哪个错误级别：

```php
$log = tris::ml('has info');
$log->mylevel(); // log with debug level
```

可以像log()方法一样设置扩展参数：

```php
$log = tris::ml($exception, [
    'user_id'   => $user_id,
]);
```

因为log类本身是个Collection类并支持重载，所以也可以这样设置扩展参数：

```php
$log->user_id = $user_id;

$log->set('nickname', $nickname)
    ->set('exception', $exception);
```

>   如果日志对象记录的message是一个abort对象，那么abort对象中的扩展参数会与log类中的合并。

## 日志扩展参数

contaxt在日志系统中被作为扩展参数使用，在abort机制中也都有用到。当日志系统接收一个abort对象时，会将两者的扩展参数合并。

扩展参数有一些特殊字段名，用于传递指定信息，例如当需要记录日志时，同时还想传递一个违例：

```php
tris::log('has error', [
    'exception' => abort::logic('user name could not be empty', 200102),
], \Psr\Log\ERROR);

// 或者
$log = tris::ml('has error');
$log->exception = abort::logic('user name could not be empty', 200102);
$log->error();
```

```exception```就是一个特殊扩展参数，支持传一个违例对象。该约定使得日志系统可以对此信息做出针对性处理。

约定的特殊扩展参数字段包括：

*   exception   违例或Error对象，该键会在捕获后被移除。
*   error       Error对象，该键会在捕获后被移除。
*   datetime    自定义的\DateTimeInterface对象。
*   primary     primary作为关键id，目前用于记录违例样本的文件名命名中
*   sampless    设置true将不记录违例样本


### 消息模版

日志中的message如果最终被记录为字串类型（传入字符串或违例），同样会应用内置的简单模版规则。所以你可以这样进行日志：

```php
$log = tris::ml('user {user_id} not found');
$log->user_id = 100;
$log->info();
```

这样记录到的message消息将会是```user 100 not found```

## 违例样本

当尝试用日志系统记录一个违例时（包括Abort），日志系统会尝试生成一个违例样本。违例样本以文本的形式记录了违例的详细追踪信息，并且以一定规则命名文件，不会重复。

样本所在目录按日志日期切片规则生成：

```<logroot>/<channel>/<slice>/```

其文件名规则为：

```<code>-<class>-<file>-<line>[-<primary>].smp```

文件名以```-```为连接符连接各个项，包括以下项目：

*   code    错误码
*   class   违例/错误类名
*   file    错误发生所在文件名
*   line    错误发生所在行
*   primary 如果有设primary值，则会把primary id带上

### 关闭违例样本

设置tris.neon下面的配置可控制违例样本的启用与关闭。

```neon
sample:
    enable:         true
```

也可以在中断发生时，或是日志时设置扩展参数```sampless=true```，这样可跳过违例样本记录。

### 选择记录违例样本的日志级别

增删tris.neon文件内sample.levels下的key可选择只对哪些错误级别记录违样本。

```neon
sample:
    levels:
        emergency:  true
        alert:      true
        critical:   true
        error:      true
        warning:    true
```

## 扩展日志功能

日志系统通过combi框架的勾子机制进行扩展。下面是一个简单的扩展演示：

```php
use Combi\Package as core;

// 日志预处理勾子
core::hook()->attach(\Combi\HOOK_LOG_PREPARE,
    function(array $record, string $to_file_path): array
{
    // 给record加上自定义参数
    $record['custom_info'] = $_REQUEST['info'] ?? null;
    return $record;
});

// 扩展自定义日志
core::hook()->attach(\Combi\HOOK_LOG, function(array $record) {
    if ($record['custom_info']) {
        file_put_contents('/tmp/custom.log',
            $record['custom_info']."\n", \FILE_APPEND);
    }
});
```

上面定义了```HOOK_LOG_PREPARE```日志预处理和```HOOK_LOG```日志勾子，当request传一个info字段时，会将此信息写入到```/tmp/custom.log```中。

关于勾子（Hook）系统的详细说明见下一章节。

### 关闭默认文件日志

tris的日志系统被设计为可以简单扩展，其自带的文件日志系统也是可以被关闭的，设置tris.neon中logger.default.to_file为false可禁止原生文件日志记录。

```neon
logger:
    default:
        to_file:            true
```

通过设置NullLogger作为provider，也可以在不影响代码的情况下完全关闭tris的日志系统。

```neon
logger:
    default:
        provider:           Combi\Tris\NullLogger
```

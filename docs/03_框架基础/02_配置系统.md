# 基础配置文件

一个combi框架的启动都依赖于一个基础配置文件。

## 配置项说明

默认推荐该文件放置到主包的项目根目录下，文件名为```config.php```。内容格式如下：

```php
<?php
return [
    'is_prod'   => false,
    'scene'     => 'default',
    'locale'    => 'zh_CN.utf8',

    'path'      => [
        'tmp'   => __DIR__ . '/tmp',
        'logs'  => __DIR__ . '/logs',
        'docs'  => __DIR__ . '/docs',
        'tests' => __DIR__ . '/tests',
    ],
];
```

**is_prod项**

该项配置为bool型，表示当前是否为生产环境。在生产环境下，很多框架内的调试机制会被关闭，并更多地依赖缓存。

**scene**

设置所使用配置场景。关于配置场景详细见下文描述。

**locale项**

所使用语言包。combi默认集成语言包功能。

**path项**

配置该包作为主包运行时的各个路径：

*   tmp，临时文件目录
*   logs，日志目录
*   docs，Markdown文档目录
*   tests，单元测试目录

## 不同环境下的基础配置文件

combi框架推荐在config.php文件同目录下，准备多个不同环境的config.php文件，其命名方式可以是：

*   config.php      默认配置，一般是开发环境
*   config.test.php 测试环境配置
*   config.prod.php 生产环境配置

类似上面那样，以便于在发布系统中进行替换，或是在入口文件中识别环境载入（通过```rt::ready()```方法）。类似的方案可以参考laravel的.env文件。

# 配置系统

## 配置格式

combi使用了Nette框架提供的neon格式，与yaml非常类似。

## 目录与文件结构

combi以包为单位管理代码，所以每个包有独立的配置文件。一般情况下包的配置文件均放在```src/config```目录下，为单层目录结构。比如：

```
src/config/service.neon
```

>   配置文件的书写与一般yaml没什么区别，neon格式只是多了Entity这一数据格式。

# 配置场景

在combi框架中场景是一个重要的配置概念。场景类似于运行环境，如常见的“生产环境”，“测试环境”等；也可以是服务器角色，或者是两者结合等。

>   一个重要的设计思想，业务代码不应试图理解场景以及对应的处理方式，而是仅读取配置，根据配置决定行为。通过配置系统来识别场景变更配置来改变业务代码的行为。

## 为配置定义场景

下面是一个基础的配置内容：

```neon
user:
    throttle_limit: 10
```

在上面这个配置中，我们给用户设置了单位时间内访问限10次。现在，我们定义了一个场景叫prod，即生产环境下，希望访问限次是50：

```neon
user:
    throttle_limit: 10
prod < user:
    throttle_limit: 50
```

如果又额外定义了一个场景test，那么在test场景下尝试读取throttle_limit配置，未指定场景的值10将会作为默认值返回。

另外，每个场景并不需要包括默认配置中的所有值，像下面这样：

```neon
user:
    throttle_limit:     10
    throttle_interval:  60
prod < user:
    throttle_limit: 50
```

如上所示除了访问限次外，还定义了限次的间隔时间60秒。而在prod场景中并不需要对interval做出变更，那只需要定义limit就行了。这样在prod中访问throttle_interval仍可正确返回60

场景定义每个层级都可以使用，以下写法和上面等价：

```neon
user:
    throttle_limit:     10
    throttle_interval:  60
    prod < throttle_limit:  50
```

## 获取配置

假设上面的配置文件处在pid为app的包内，文件名为```src/config/base.neon```，那么包内的访问方式是：

```php
$limit = inner::config('base')->user['throttle_limit'];
```

包外的访问方式则是：

```php
$limit = rt::app()->config('base')->user['throttle_limit'];
```

看起来有点复杂，拆解一下：

```php
$package = rt::app(); // 返回包对象
$config  = $package->config('base'); // 返回base.neon该文件的配置对象
$array   = $config->user; // 获取base.neon文件中user key解析后的数组
$limit   = $array['throttle_limit'];
```

## 引用包配置重载

combi基于包的开发模式鼓励对功能模块的重用，因此涉及到在项目包中引用其他包的情况。在一些情况下，需要对其他包中的配置进行更改，这时可按约定在主包中对引用包的配置进行重载。

在主包的配置目录中，可以重载其他引用包的配置文件，方法是在```src/config```目录下建立要重载包的pid同名目录，在其中创建对应的配置文件即可。

假设上文所示的配置处于pid名为user的包中，配置文件名```src/config/base.neon```，内容如下：

```neon
user:
    throttle_limit:     10
    throttle_interval:  60
prod < user:
    throttle_limit: 50
```

现在以app包作为主包引用user包，需要重载user包的base.neon配置，将在线limit改为100。那么在app包中创建```src/config/user/base.neon```文件，内容如下：

```neon
user:
    throttle_limit:     10
    throttle_interval:  60
prod < user:
    throttle_limit: 100
```

**配置重载的注意事项**

*   配置重载与场景不同，需要提供完整的配置内容，省略的配置不会从引用包中读取。
*   引用包中的配置只在主包中被重载，引用包自带的重载不会生效。

## 配置文件缓存

配置系统会对neon文件解析后进行缓存，缓存文件存于主包的```tmp/config```目录下。

在非生产环境下，每次载入配置时会检查文件更新日期并刷新缓存；在生产环境中则需要手动删除目录下文件。

> combi提供的命令行工具有提供相关的维护脚本，可移步相关章节了解。




# 运行时对象

Runtime类是Combi框架的核心，在框架载入时自动创建全局唯一单例。在combi中，应用由若干个包（package）组成，这些包以唯一包名（pid）的形式挂载于runtime对象中。

调用函数```combi()```可以获取combi运行时对象，假设访问pid为app的包的代码如下：

```{php}
<?php
$package = combi()->app;
```

## Runtime的主要方法

```{php}
<?php
if (combi()->isProd()) {
    // do something...
}
```

```isProd():bool```方法可供判断是否处在生产环境中。

# 包对象 Package

包是构造combi应用的基本颗粒，一个包中会包括代码库、配置、资源等业务所需的文件，并通过composer被其他包引用。

>   一般情况下包对象会在composer载入时自动创建，因此在```composer.json```中需注意引用顺序应把combi核心库放在前面。

当开始构建一个新的combi包的时候，都需要创建一个自己的包对象并继承于Package基类：

```{php}
<?php

namespace My\Zone;

class Package extends \Combi\Core\Package
{
}
```

## 默认pid生成规则

每个包都需要有一个全局唯一的包名，当构建一个需要被其他系统所引用的包的时候尤其重要。

默认情况下，package基类会使用子类所处的命名空间加工后作为pid，加工规则是全部转小写，并把```\```符转为下划线。

以上面的包举例，通过pid在runtime中获取的方法如下：

```{php}
<?php
$package = combi()->my_zone;
```

## 访问Package对象

直接通过Package对象能访问到的资源有以下几种：

*   在配置文件中声明的服务
*   包对象作为容器注册的资源
*   包对象自带的预留方法

### 访问包内部的服务

先忽略配置服务的细节，可以简单地把服务理解为写在配置文件中，已经封装好依赖关系的可用对象。

如果有一个服务叫mail，并且提供一个create方法，那么通过包对象访问的方式可能是这样：

```{php}
<?php
$mail = comb()->my_zone->mail()->create();
```

>   需要注意，服务将以包对象的一个虚拟方法的形式访问，而不是属性。

### Combi的资源调用路径

如上所示，```runtime/package/service/method```这种层级是combi框架中的资源调中路径的典型形式。通过这种结构定义，也为各个包之间的高度分离提供基础。

再举例，假设mail服务又包含了一个send()方法，那么可以这样调用到：

```{php}
<?php
combi()->my_zone->mail()->send($address, $subject, $content);
```

### 使用包容器

可以简单地把包看作一个容器，把包内业务中需要用到的对象/变量等存放进去。

```{php}
<?php

combi()->my_zone->config = [
    'timeout'   => 3000,
];

combi()->my_zone->user = new User();
```

包容器支持传递一个闭包对对象进行初始化，这样的优势在于可以在用到该资源时才进行初始化。

```{php}
<?php

combi()->my_zone->db = function(): DB {
    return new DB();
}
```

>   注意，只支持传闭包对象```Closure```进行初始化，带```__invoke()```的对象不会在第一次访问时触发```__invoke()```方法并替换原对象。

### 预留方法

Package基类有一些预留方法（当然继承后也可以额外添加），这些预留方法不能被用作服务名注册。

```{php}
echo combi()->my_zone->pid(); // 获取包名

$mylog_path = combi()->my_zone->path('tmp', 'mylog'); // 获取一个目录的路径
$mylog_dir  = combi()->my_zone->dir('tmp', 'mylog'); // 获取一个目录资源对象

$config = combi()->my_zone->config('myconfig'); // 获取一个配置文件对象
```

# Package包对象及概念

- package类本身作为基础容器对象，容器中的单元均通过属性重载获取。
    - 使用function() {}方法给某个容器设为闭包（\Closure），此时调用此方法将设置其返回值覆盖该单元。
    - 主要用于实现容器内对象初始调用时才加载的功能。
    - 如果需要使用类似闭包的效果来调用某个容器单元，可以使用一个带__invoke()方法的匿名类实现。
- 注册进入的service通过方法重载获取。
- 默认提供container()方法来返回自身。（主要供inner动态类访问动态属性）
- 默认提供pid(), bootstrap(), factory(), resource(), config()这三个服务。


自定义包名介绍
